import { NextRequest, NextResponse } from 'next/server';
import { logger } from '@/lib/logger';
import { createClient } from '@supabase/supabase-js';
import crypto from 'crypto';

export const dynamic = 'force-dynamic';

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL || '';
const supabaseKey = process.env.SUPABASE_SERVICE_ROLE_KEY || '';
const supabase = createClient(supabaseUrl, supabaseKey);

// Admin credentials from environment (HASHED!)
// Format: salt:hash (generated by scripts/generate-hash.js)
const ADMIN_USERNAME_HASH = process.env.ADMIN_USERNAME_HASH || '';
const ADMIN_PASSWORD_HASH = process.env.ADMIN_PASSWORD_HASH || '';
const ADMIN_EMAIL = process.env.ADMIN_EMAIL || '';
const ADMIN_SECRET_PATH = process.env.ADMIN_SECRET_PATH || '';

// Hash verification function
function verifyHash(input: string, storedHash: string): boolean {
  if (!storedHash || !storedHash.includes(':')) return false;

  const [salt, hash] = storedHash.split(':');
  const inputHash = crypto
    .createHash('sha256')
    .update(input + salt)
    .digest('hex');

  return inputHash === hash;
}

// Generate 6-digit code
function generateCode(): string {
  return Math.floor(100000 + Math.random() * 900000).toString();
}

// Store codes temporarily (in production use Redis)
const pendingCodes: Map<string, { code: string; expires: number; attempts: number }> = new Map();

// Rate limiting
const loginAttempts: Map<string, { count: number; blockedUntil: number }> = new Map();

function isBlocked(ip: string): boolean {
  const attempt = loginAttempts.get(ip);
  if (!attempt) return false;
  if (attempt.blockedUntil > Date.now()) return true;
  if (attempt.blockedUntil < Date.now()) {
    loginAttempts.delete(ip);
    return false;
  }
  return false;
}

function recordFailedAttempt(ip: string): void {
  const attempt = loginAttempts.get(ip) || { count: 0, blockedUntil: 0 };
  attempt.count++;

  // Block for 15 minutes after 5 failed attempts
  if (attempt.count >= 5) {
    attempt.blockedUntil = Date.now() + 15 * 60 * 1000;
    attempt.count = 0;
  }

  loginAttempts.set(ip, attempt);
}

function clearAttempts(ip: string): void {
  loginAttempts.delete(ip);
}

export async function POST(request: NextRequest) {
  try {
    const ip = request.headers.get('x-forwarded-for') || request.headers.get('x-real-ip') || 'unknown';
    const body = await request.json();
    const { action, username, password, code, sessionId } = body;

    // Check if IP is blocked
    if (isBlocked(ip)) {
      return NextResponse.json(
        { error: 'Zbyt wiele pr贸b logowania. Spr贸buj za 15 minut.' },
        { status: 429 }
      );
    }

    // Step 1: Verify username and password (using hashes)
    if (action === 'login') {
      const usernameValid = verifyHash(username, ADMIN_USERNAME_HASH);
      const passwordValid = verifyHash(password, ADMIN_PASSWORD_HASH);

      if (!usernameValid || !passwordValid) {
        recordFailedAttempt(ip);

        // Log failed attempt
        try {
          await supabase.from('admin_login_logs').insert({
            ip_address: ip,
            success: false,
            reason: 'invalid_credentials',
          });
        } catch {}

        return NextResponse.json(
          { error: 'Nieprawidowe dane logowania' },
          { status: 401 }
        );
      }

      // Generate verification code
      const verificationCode = generateCode();
      const newSessionId = `session_${Date.now()}_${Math.random().toString(36).slice(2)}`;

      // Store code (expires in 5 minutes)
      pendingCodes.set(newSessionId, {
        code: verificationCode,
        expires: Date.now() + 5 * 60 * 1000,
        attempts: 0,
      });

      // Store code in database and send email
      try {
        // Save code to database
        await supabase.from('admin_verification_codes').insert({
          session_id: newSessionId,
          code: verificationCode,
          email: ADMIN_EMAIL || 'kontakt@kupmax.pl',
          expires_at: new Date(Date.now() + 5 * 60 * 1000).toISOString(),
          used: false,
        });

        // Send email via Resend if API key exists
        const resendKey = process.env.RESEND_API_KEY;
        if (resendKey && ADMIN_EMAIL) {
          await fetch('https://api.resend.com/emails', {
            method: 'POST',
            headers: {
              'Authorization': `Bearer ${resendKey}`,
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              from: 'KUPMAX Admin <onboarding@resend.dev>',
              to: ADMIN_EMAIL,
              subject: ' Kod logowania KUPMAX Admin',
              html: `
                <div style="font-family: Arial, sans-serif; padding: 20px; background: #f5f5f5;">
                  <div style="max-width: 400px; margin: 0 auto; background: #fff; border: 2px solid #000080; padding: 20px;">
                    <h2 style="color: #000080; margin-top: 0;"> KUPMAX Admin</h2>
                    <p>Tw贸j kod weryfikacyjny:</p>
                    <div style="background: #000080; color: #fff; font-size: 32px; padding: 15px; text-align: center; letter-spacing: 8px; font-weight: bold;">
                      ${verificationCode}
                    </div>
                    <p style="color: #666; font-size: 12px; margin-top: 15px;">
                      Kod wygasa za 5 minut.<br>
                      Jeli to nie Ty - zignoruj t wiadomo.
                    </p>
                  </div>
                </div>
              `,
            }),
          });
        }
      } catch (e) {
        logger.log('Could not store/send verification code:', e);
      }

      return NextResponse.json({
        success: true,
        message: 'Kod weryfikacyjny wysany',
        sessionId: newSessionId,
        // In development, show code (remove in production!)
        ...(process.env.NODE_ENV === 'development' ? { devCode: verificationCode } : {}),
      });
    }

    // Step 2: Verify 2FA code
    if (action === 'verify') {
      if (!sessionId || !code) {
        return NextResponse.json(
          { error: 'Brak kodu lub sesji' },
          { status: 400 }
        );
      }

      const pending = pendingCodes.get(sessionId);

      if (!pending) {
        return NextResponse.json(
          { error: 'Sesja wygasa. Zaloguj si ponownie.' },
          { status: 401 }
        );
      }

      if (pending.expires < Date.now()) {
        pendingCodes.delete(sessionId);
        return NextResponse.json(
          { error: 'Kod wygas. Zaloguj si ponownie.' },
          { status: 401 }
        );
      }

      pending.attempts++;

      if (pending.attempts > 3) {
        pendingCodes.delete(sessionId);
        recordFailedAttempt(ip);
        return NextResponse.json(
          { error: 'Zbyt wiele bdnych pr贸b. Zaloguj si ponownie.' },
          { status: 401 }
        );
      }

      if (pending.code !== code) {
        return NextResponse.json(
          { error: `Nieprawidowy kod. Pozostao pr贸b: ${3 - pending.attempts}` },
          { status: 401 }
        );
      }

      // Success! Generate auth token
      pendingCodes.delete(sessionId);
      clearAttempts(ip);

      const authToken = `admin_${Date.now()}_${Math.random().toString(36).slice(2)}${Math.random().toString(36).slice(2)}`;

      // Store valid session
      try {
        await supabase.from('admin_sessions').insert({
          token: authToken,
          ip_address: ip,
          expires_at: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(), // 24 hours
        });

        // Log successful login
        await supabase.from('admin_login_logs').insert({
          ip_address: ip,
          success: true,
          reason: 'login_success',
        });
      } catch {}

      return NextResponse.json({
        success: true,
        token: authToken,
        message: 'Zalogowano pomylnie!',
      });
    }

    // Verify existing token
    if (action === 'verify-token') {
      const { token } = body;

      if (!token) {
        return NextResponse.json({ valid: false });
      }

      try {
        const { data, error } = await supabase
          .from('admin_sessions')
          .select('*')
          .eq('token', token)
          .gte('expires_at', new Date().toISOString())
          .single();

        if (error || !data) {
          return NextResponse.json({ valid: false });
        }

        return NextResponse.json({ valid: true });
      } catch {
        return NextResponse.json({ valid: false });
      }
    }

    // Logout
    if (action === 'logout') {
      const { token } = body;

      if (token) {
        try {
          await supabase
            .from('admin_sessions')
            .delete()
            .eq('token', token);
        } catch {}
      }

      return NextResponse.json({ success: true });
    }

    return NextResponse.json({ error: 'Nieznana akcja' }, { status: 400 });

  } catch (error) {
    logger.error('Admin auth error:', error);
    return NextResponse.json(
      { error: 'Bd serwera' },
      { status: 500 }
    );
  }
}

// GET - return secret path (for checking if URL is valid)
export async function GET(request: NextRequest) {
  // This endpoint can be used to verify the secret path
  const url = new URL(request.url);
  const checkPath = url.searchParams.get('path');

  if (checkPath === ADMIN_SECRET_PATH) {
    return NextResponse.json({ valid: true });
  }

  return NextResponse.json({ valid: false });
}
